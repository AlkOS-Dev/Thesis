\documentclass[a4paper,9pt,twoside]{report}

% ----------------------   PREAMBLE PART ------------------------------

% ------------------------ ENCODING & LANGUAGES ----------------------

\usepackage[utf8]{inputenc}
\usepackage[MeX]{polski}
\usepackage[T1]{fontenc}
\usepackage[english, polish]{babel}


\usepackage{amsmath, amsfonts, amsthm, latexsym}

\usepackage[final]{pdfpages}
\usepackage[backend=biber, style=numeric, sorting=none]{biblatex}
\addbibresource{references.bib}


\usepackage{commath}

\usepackage[hidelinks]{hyperref}


% ---------------- MARGINS, INDENTATION, LINESPREAD ------------------

\usepackage[inner=20mm, outer=20mm, bindingoffset=10mm, top=25mm, bottom=25mm]{geometry}


\linespread{1.5}
\allowdisplaybreaks

\usepackage{indentfirst}
\setlength{\parindent}{5mm}


%---------------- RUNNING HEAD - CHAPTER NAMES, PAGE NUMBERS ETC. -------------------

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[LE,RO]{\thepage} 
\fancyhead[LO]{\sc \nouppercase{\rightmark}}
\fancyhead[RE]{\sc \leftmark}

\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}

\renewcommand{\headrulewidth}{0 pt}


\fancypagestyle{plain}{
  \fancyhf{}
  \fancyfoot[LE,RO]{\thepage}
  
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0.0pt}
}

%---------------- C++ listing -------------------

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{cppstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true, 
    captionpos=b,
    keepspaces=true,                 
    numbers=left,
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
    frame=single,
    language=C++,
    morekeywords={constexpr, nullptr, size_t, uint64_t}
}
\lstset{style=cppstyle}
\renewcommand{\lstlistingname}{C++ Code Snippet}

% --------------------------- DRAWING ---------------------

\usepackage{tikz}
\usetikzlibrary{shapes, arrows.meta, positioning, calc, chains}

% --------------------------- CHAPTER HEADERS ---------------------

\usepackage{titlesec}
\titleformat{\chapter}
  {\normalfont\Large \bfseries}
  {\thechapter.}{1ex}{\Large}

\titleformat{\section}
  {\normalfont\large\bfseries}
  {\thesection.}{1ex}{}
\titlespacing{\section}{0pt}{30pt}{20pt} 

    
\titleformat{\subsection}
  {\normalfont \bfseries}
  {\thesubsection.}{1ex}{}


% ----------------------- TABLE OF CONTENTS SETUP ---------------------------

\def\cleardoublepage{\clearpage\if@twoside
\ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage
\if@twocolumn\hbox{}\newpage\fi\fi\fi}


\usepackage{etoolbox}
\makeatletter
\patchcmd{\l@chapter}
  {\hfil}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill}
  {}{}
\makeatother

\usepackage{titletoc}
\makeatletter
\titlecontents{chapter}
  [0pt]
  {}
  {\bfseries \thecontentslabel.\quad}
  {\bfseries}
  {\bfseries\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill\contentspage}

\titlecontents{section}
  [1em]
  {}
  {\thecontentslabel.\quad}
  {}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill\contentspage}

\titlecontents{subsection}
  [2em]
  {}
  {\thecontentslabel.\quad}
  {}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill\contentspage}
\makeatother



% ---------------------- TABLES AD FIGURES NUMBERING ----------------------

\renewcommand*{\thetable}{\arabic{chapter}.\arabic{table}}
\renewcommand*{\thefigure}{\arabic{chapter}.\arabic{figure}}


% ------------- DEFINING ENVIRONMENTS FOR THEOREMS, DEFINITIONS ETC. ---------------

\makeatletter
\newtheoremstyle{definition}
{3ex}
{3ex}
{\upshape}
{}
{\bfseries}
{.}
{.5em}
{\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}
\makeatother

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

% --------------------- END OF PREAMBLE PART (MOSTLY) --------------------------





% -------------------------- USER SETTINGS ---------------------------

\newcommand{\tytul}{Funkcjonalne jądro systemu operacyjnego: AlkOS}
\renewcommand{\title}{From Bare Metal to a Functional Kernel: The AlkOS Operating System}
\newcommand{\type}{Engineer}
\newcommand{\supervisor}{mgr inż. Paweł Sobótka}



\begin{document}
\sloppy
\selectlanguage{english}

\includepdf[pages=-]{titlepage-en}

\null\thispagestyle{empty}\newpage

% ------------------ PAGE WITH SIGNATURES --------------------------------

%\thispagestyle{empty}\newpage
%\null
%
%\vfill
%
%\begin{center}
%\begin{tabular}[t]{ccc}
%............................................. & \hspace*{100pt} & .............................................\\
%supervisor's signature & \hspace*{100pt} & author's signature
%\end{tabular}
%\end{center}
%


% ---------------------------- ABSTRACT -----------------------------

{  \fontsize{12}{14} \selectfont
\begin{abstract}

\begin{center}
\title
\end{center}

TODO

\end{abstract}
}

\null\thispagestyle{empty}\newpage

%% --------------------------- DECLARATIONS ------------------------------------
%
%%
%%	IT IS NECESSARY OT ATTACH FILLED-OUT AUTORSHIP DEECLRATION. SCAN (IN PDF FORMAT) NEEDS TO BE PLACED IN scans FOLDER AND IT SHOULD BE CALLED, FOR EXAMPLE, DECLARATION_OF_AUTORSHIP.PDF. IF THE FILENAME OR FILEPATH IS DIFFERENT, THE FILEPATH IN THE NEXT COMMAND HAS TO BE ADJUSTED ACCORDINGLY.
%%
%%	command attacging the declarations of autorship
%%
%\includepdf[pages=-]{scans/declaration-of-autorship}
%\null\thispagestyle{empty}\newpage
%
%% optional declaration
%%
%%	command attaching the declaataration on granting a license
%%
%\includepdf[pages=-]{scans/declaration-on-granting-a-license}
%%
%%	.tex corresponding to the above PDF files are present in the 3. declarations folder 
%
\null\thispagestyle{empty}\newpage
% ------------------- TABLE OF CONTENTS ---------------------
\selectlanguage{english}
\pagenumbering{gobble}
\tableofcontents
\thispagestyle{empty}
\newpage % IF YOU HAVE EVEN QUANTITY OD PAGES OF TOC, THEN REMOVE IT OR ADD \null\newpage FOR DOUBLE BLANK PAGE BEFORE INTRODUCTION


% -------------------- THE BODY OF THE THESIS --------------------------------

\null\thispagestyle{empty}\newpage
\pagestyle{fancy}
\pagenumbering{arabic}
\setcounter{page}{11}


\chapter{Introduction}
\markboth{}{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\section{Theoretical Background} 
TODO

\subsubsection{Interrupts}
\subsubsection{Exceptions}

\section{Scope of the Thesis} 
TODO
\section{Limitations and Assumptions}
TODO
\section{Achieved Functionalities} 
TODO
\section{Work Division -- Code} 
TODO
\section{Work Division -- Thesis}
TODO

% ==================================================================

\chapter{Creating an Operating System from Scratch}

% Tutorial jak zrobic os krok po kroku tak zeby kazdy zrozumial pozdro

\section{Host Environment}
TODO
\subsection{Cross-Compilation Toolchain}
TODO
\subsection{Building Machinery}
TODO
\subsection{Emulation}
TODO
\subsection{Rootfs}
TODO
\subsection{Compiling Userspace Programs}
TODO
\subsection{Testing}
TODO

\section{Target Environment}
TODO
\subsection{Implementation of Libc and Libc++}
TODO
\subsection{Bootloader}
TODO
\subsection{Memory Preloading and Discovery}
TODO
\subsection{Discovering and Enabling CPU Features}
TODO
\subsection{Enabling Interrupts and Exceptions}
TODO
\subsection{Memory Management}
TODO

\subsubsection{Physical Memory Management}
TODO
\subsubsection{Virtual Memory Management}
TODO
\subsubsection{Virtual Address Space}
TODO

\subsection{Discovering External Devices and System Capabilities}
TODO

\subsubsection{Clocks}
TODO
\subsubsection{Event Clocks}
TODO

\subsection{File Systems}
TODO
\subsection{Screen Drawing}
TODO
\subsection{Scheduling}
TODO

\subsubsection{Process}
TODO
\subsubsection{Thread}
TODO
\subsubsection{Meta-Scheduler}
TODO
\subsubsection{Policies}
TODO
\subsubsection{Context Switch}
TODO
\subsubsection{Context Conversion}
TODO

\subsection{User Space}
TODO

\subsubsection{Syscalls}
TODO
\subsubsection{Libc System Headers}
TODO
\subsubsection{Conversion to User Space}
TODO


% ==================================================================

% jak to robia inni, same najwazniejsze elementy

\chapter{Analysis of Existing Solutions}

\section{Linux}
TODO

\subsection{Scheduler}
TODO
\subsection{Timing}
TODO
\subsection{Memory Management}
TODO
\subsection{System Interface}
TODO

\section{Minix}
TODO

\subsection{Scheduler}
TODO
\subsection{Timing}
TODO
\subsection{Memory Management}
TODO
\subsection{System Interface}
TODO

% ==================================================================

\chapter{Supporting Multiple Hardware Platforms} 
TODO

\section{HAL -- Hardware Abstraction Layer} 
TODO

\section{x86-64 Support} 
TODO
\subsection{Technical Debt}
TODO
\subsection{Common Pitfalls}
TODO


% ==================================================================

\chapter{Our Implementation} 
TODO

\section{Bootloader}
TODO

\section{Assumptions}
\subsubsection{}

\section{Interrupts}

Interrupt handling is very important part of the operating system. Without interrupts manual polling the devices or states would be horribly inefficient and resource wastefull.
Additionally it allows it to be much more responsive. For example, if we press a keyboard button, except handling the driver or reactiong to the device the os may want to change 
currently running thread to the thread which will consume this information and return back to the previous task later. Diving deeper into this the OS utilizes interrupt mechanism to change
context if some task takes too long and is not willing to give cpu time to others - more precisly it is done by Timing devices like PIT, HPET or LAPIC Timer and interrupt handling their events.

\subsection{Interrupt Types}

On most platforms we generally have three classes of interrupts:

\begin{itemize}
  \item \textbf{Exceptions} - generated by the CPU and used to inform the kernel about situation which needs special care like Page Fault or invalid instruction operans etc.
  \item \textbf{Hardware Interrupts} - generated by external devices, used to efficiently communicate with the kernel without polling
  \item \textbf{Software Interupts} - initiated by the software, for example on x86-64 instruction \textbf{INT 0x80} would initiate interrupt with number \textbf{0x80}
\end{itemize}

\subsection{x86-64 Interrupts}

\subsubsection{Interrupt Handling}
On x86-64 if some type of interrupt takes place it has some unique number, which maps directly to the entry in table called \textbf{Interrupt Descriptor Table} \cite{IntelManual-Interrupts}.
This table contains information what the CPU should do as a reaction on the interrupt. This infromation contains:

\begin{lstlisting}[caption={Idt entyry layout}, label={lst:idtEntry}]
  enum class IdtPrivilegeLevel : u8 { kRing0 = 0, kRing1 = 1, kRing2 = 2, kRing3 = 3 };

  struct PACK IdtEntryFlags {
      IdtGateType type : 4;
      u8 zero : 1;
      IdtPrivilegeLevel dpl : 2;
      u8 present : 1;
  };
  static_assert(sizeof(IdtEntryFlags) == 1);
  
  /**
   * @brief Data layout of x86_64 interrupt service routines, refer to intel manual for details
   */
  struct PACK IdtEntry {
      u16 isr_low;    // The lower 16 bits of the ISR's address
      u16 kernel_cs;  // The GDT segment selector that the CPU
                      //  will load into CS before calling the ISR
      u8 ist;         // The IST in the TSS that the CPU will load into RSP
      IdtEntryFlags attributes;  // Type and attributes; see the IDT page
      u16 isr_mid; // The higher 16 bits of the lower 32 bits of the ISR's address
      u32 isr_high; // The higher 32 bits of the ISR's address
      u32 reserved; // Set to zero
  };
\end{lstlisting}

The most important part here is the address of the function which will be invoked as a reaction on the interrupt (\textbf{isr}), which is splitted here into parts.
Very imporatnt field is \textbf{kernel\_cs}, which points to the code segment \cite{IntelManual-Segments}, which will be loaded before executing the function. In x86-64 we have 4 levels of permissions 
(as shown in \ref{lst:idtEntry}). We assume that kernel always operates in ring0 (the most priviliged one) and thus we only have single ring0 kernel segment, which we always write to this field. 
On the other hand we can specify miniaml required permissions level to handle the exception - \textbf{IdtPrivilegeLevel dpl}, which will be usefull for creating syscalls - userspace invoked
software interrupt.

\subsubsection{Interrupt Service Routines}

As it might be obvious but function handling interrupts slightly differs from usual function we write and compiler generates.
When the CPU calls the handling function it first pushes these values on the stack in given order (each of them is 8-byte):

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
      node distance=0cm,
      start chain=going below,
      stacknode/.style={
          draw, 
          minimum width=5cm, 
          minimum height=1cm, 
          outer sep=0pt, 
          font=\ttfamily
      },
      labelnode/.style={
          minimum height=1cm,
          font=\footnotesize\sffamily,
          anchor=east
      }
  ]
  
  \node (highmem) at (0, 1) {Higher address (High Memory)};
  \draw[->] (highmem) -- (0, 0.2);

  \node [stacknode, on chain, fill=gray!10] (ss) {Stack Segment};
  \node [stacknode, on chain, fill=gray!10] (rsp) {Original Stack Pointer};
  \node [stacknode, on chain, fill=gray!10] (rflags) {Rflags};
  \node [stacknode, on chain, fill=gray!10] (cs) {Code Segment};
  \node [stacknode, on chain, fill=gray!10] (rsp) {Instruction Address};
  \node [stacknode, on chain, fill=gray!10] (error) {Error Code (optional)};
  \draw[<-, thick, red] (error.east) -- ++(1.5,0) node[right, text=red] {ESP (Stack Pointer)};

  \node [below=0.5cm of error] (lowmem) {Lower address (Low Memory)};
  \draw[->] (lowmem.north) -- (error.south);

  \end{tikzpicture}
  \caption{Interrupt Service Routine stack layout on entry}
  \label{fig:stackframe}
\end{figure}

The layout above (\ref{fig:stackframe}) is called \textbf{Interrupt Frame} and is one of the most imporatnt architecture concepts in the kernel as based on this we will be building context switches, context conversion or jumping to userspace (ring3).
After preparing the stack CPU changes code segment as instrumented in \textbf{IDT entry} (\ref{lst:idtEntry}) and swaps stack pointers to kernel stack if we change ring (ring3 -> ring0, in other words if interrupt happens from userspace),
it is done by mechanism called TSS (For simplicity we will not go into details, please refer to \cite{osdev-tss}). The final difference is that \textbf{ISR} must return using special instruction \textbf{IRETQ} \cite{IntelManual-Interrupts},
which rewinds all actions we described before in proper order (including ring change and jumping to proper code segment). Major problem with compiler generated function is that it modifies the stack before and after the function code, so to have full control and omit compiler bugs we introduced clean solution to split definition of handlers to assembly wrappers,
performing necessary actions defined by the architecture and independant interrupt handling code defined in arch-agnostic kernel.

\subsection{Unified Interrupt Frame}
\subsection{Logical Interrupt Table}


\section{Memory Management}
TODO
\section{Timing}
TODO
\section{File System}
TODO
\section{Scheduling}
TODO

% ==================================================================

\chapter{Results}
TODO

\section{User's Manual}
TODO

\subsection{Building and Running the OS}
TODO

\subsection{Writing Own Programs}
TODO

\subsection{Libc alkos.h}
TODO

\subsection{Syscalls}
TODO

\section{Example Programs}
TODO

\section{Performance Analysis}
TODO

\subsection{KMalloc Performance}
TODO

\subsection{KFree Performance}
TODO

\subsection{Context Switch Performance}
TODO

\subsection{Syscall Performance}
TODO

\subsection{Scheduler Tests}
TODO

% ------------------------------- BIBLIOGRAPHY ---------------------------

\printbibliography[heading=bibintoc]

\pagenumbering{gobble}
\thispagestyle{empty}



% ----------------------- LIST OF SYMBOLS AND ABBREVIATIONS ------------------
\chapter*{List of symbols and abbreviations}

\begin{tabular}{cl}
PIC & Programmable Interrupt Controller \\
APIC & Advanced Programmable Interrupt Controller \\
LAPIC & Local Advanced Programmable Interrupt Controller \\
PIT & Programmable Interrupt Timer \\
IDT & Interrupt Descriptor Table \\
TSS & Task State Segment \\
ISR & Interrupt Service Routine
\end{tabular}
\\
If you don't need it, delete it.
\thispagestyle{empty}


% ----------------------------  LIST OF FIGURES --------------------------------
\listoffigures
\thispagestyle{empty}

% -----------------------------  LIST OF TABLES --------------------------------
\renewcommand{\listtablename}{List of Tables}
\listoftables
\thispagestyle{empty}

\end{document}

% ==================================================================
% TODOS:
% - wytlumaczyc na starcie co zakladamy etc i dlaczego np segmenty
