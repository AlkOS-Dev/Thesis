\documentclass[a4paper,9pt,twoside]{report}

% ----------------------   PREAMBLE PART ------------------------------

% ------------------------ ENCODING & LANGUAGES ----------------------

\usepackage[utf8]{inputenc}
\usepackage[MeX]{polski}
\usepackage[T1]{fontenc}
\usepackage[polish, english]{babel}


\usepackage{amsmath, amsfonts, amsthm, latexsym}

\usepackage[final]{pdfpages}
\usepackage[backend=biber, style=numeric, sorting=none]{biblatex}
\addbibresource{references.bib}


\usepackage{commath}

\usepackage[hidelinks]{hyperref}

\usepackage[inkscapepath=../output/svg/]{svg}


% ---------------- MARGINS, INDENTATION, LINESPREAD ------------------

\usepackage[inner=20mm, outer=20mm, bindingoffset=10mm, top=25mm, bottom=25mm]{geometry}


\linespread{1.5}
\allowdisplaybreaks

\usepackage{indentfirst}
\setlength{\parindent}{5mm}


%---------------- RUNNING HEAD - CHAPTER NAMES, PAGE NUMBERS ETC. -------------------

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[LE,RO]{\thepage} 
\fancyhead[LO]{\sc \nouppercase{\rightmark}}
\fancyhead[RE]{\sc \leftmark}

\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}

\renewcommand{\headrulewidth}{0 pt}


\fancypagestyle{plain}{
  \fancyhf{}
  \fancyfoot[LE,RO]{\thepage}
  
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0.0pt}
}

%---------------- code listings -------------------

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{cppstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true, 
    captionpos=b,
    keepspaces=true,                 
    numbers=left,
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    language=C++,
    morekeywords={constexpr, nullptr, size_t, uint64_t}
}
\lstset{style=cppstyle}
\renewcommand{\lstlistingname}{C++ Code Snippet}

\lstdefinestyle{nasmstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true, 
    captionpos=b,
    keepspaces=true,                 
    numbers=left,
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    language=[x86masm]Assembler,
    morekeywords={rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14, r15,
                  eax, ebx, ecx, edx, esi, edi, ebp, esp,
                  cr0, cr2, cr3,
                  mov, push, pop, call, ret, int, iretq, jmp, je, jne, jg, jl, cmp, test,
                  add, sub, mul, div, inc, dec, xor, or, and,
                  lidt, lgdt, sti, cli, hlt,
                  section, global, extern, db, dw, dd, dq, resb, resw, resd, resq,
                  macro, endmacro, \%define}
}

% --------------------------- DRAWING ---------------------

\usepackage{tikz}
\usetikzlibrary{shapes, arrows.meta, positioning, calc, chains}
\usepackage[colorinlistoftodos]{todonotes}

% --------------------------- CHAPTER HEADERS ---------------------

\usepackage{titlesec}
\titleformat{\chapter}
  {\normalfont\Large \bfseries}
  {\thechapter.}{1ex}{\Large}

\titleformat{\section}
  {\normalfont\large\bfseries}
  {\thesection.}{1ex}{}
\titlespacing{\section}{0pt}{30pt}{20pt} 

    
\titleformat{\subsection}
  {\normalfont \bfseries}
  {\thesubsection.}{1ex}{}


% ----------------------- TABLE OF CONTENTS SETUP ---------------------------

\def\cleardoublepage{\clearpage\if@twoside
\ifodd\c@page\else\hbox{}\thispagestyle{empty}\newpage
\if@twocolumn\hbox{}\newpage\fi\fi\fi}


\usepackage{etoolbox}
\makeatletter
\patchcmd{\l@chapter}
  {\hfil}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill}
  {}{}
\makeatother

\usepackage{titletoc}
\makeatletter
\titlecontents{chapter}
  [0pt]
  {}
  {\bfseries \thecontentslabel.\quad}
  {\bfseries}
  {\bfseries\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill\contentspage}

\titlecontents{section}
  [1em]
  {}
  {\thecontentslabel.\quad}
  {}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill\contentspage}

\titlecontents{subsection}
  [2em]
  {}
  {\thecontentslabel.\quad}
  {}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill\contentspage}
\makeatother



% ---------------------- TABLES AD FIGURES NUMBERING ----------------------

\renewcommand*{\thetable}{\arabic{chapter}.\arabic{table}}
\renewcommand*{\thefigure}{\arabic{chapter}.\arabic{figure}}


% ------------- DEFINING ENVIRONMENTS FOR THEOREMS, DEFINITIONS ETC. ---------------

\makeatletter
\newtheoremstyle{definition}
{3ex}
{3ex}
{\upshape}
{}
{\bfseries}
{.}
{.5em}
{\thmname{#1}\thmnumber{ #2}\thmnote{ (#3)}}
\makeatother

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

% --------------------- END OF PREAMBLE PART (MOSTLY) --------------------------





% -------------------------- USER SETTINGS ---------------------------

\newcommand{\tytul}{Funkcjonalne jądro systemu operacyjnego: AlkOS}
\renewcommand{\title}{From Bare Metal to a Functional Kernel: The AlkOS Operating System}
\newcommand{\type}{Engineer}
\newcommand{\supervisor}{mgr inż. Paweł Sobótka}



\begin{document}
\sloppy
\selectlanguage{english}

\includepdf[pages=-]{titlepage-en}

\null\thispagestyle{empty}\newpage

% ------------------ PAGE WITH SIGNATURES --------------------------------

%\thispagestyle{empty}\newpage
%\null
%
%\vfill
%
%\begin{center}
%\begin{tabular}[t]{ccc}
%............................................. & \hspace*{100pt} & .............................................\\
%supervisor's signature & \hspace*{100pt} & author's signature
%\end{tabular}
%\end{center}
%


% ---------------------------- ABSTRACT -----------------------------

{  \fontsize{12}{14} \selectfont
\begin{abstract}

\begin{center}
\title
\end{center}

TODO

\end{abstract}
}

\null\thispagestyle{empty}\newpage

%% --------------------------- DECLARATIONS ------------------------------------
%
%%
%%	IT IS NECESSARY OT ATTACH FILLED-OUT AUTORSHIP DEECLRATION. SCAN (IN PDF FORMAT) NEEDS TO BE PLACED IN scans FOLDER AND IT SHOULD BE CALLED, FOR EXAMPLE, DECLARATION_OF_AUTORSHIP.PDF. IF THE FILENAME OR FILEPATH IS DIFFERENT, THE FILEPATH IN THE NEXT COMMAND HAS TO BE ADJUSTED ACCORDINGLY.
%%
%%	command attacging the declarations of autorship
%%
%\includepdf[pages=-]{scans/declaration-of-autorship}
%\null\thispagestyle{empty}\newpage
%
%% optional declaration
%%
%%	command attaching the declaataration on granting a license
%%
%\includepdf[pages=-]{scans/declaration-on-granting-a-license}
%%
%%	.tex corresponding to the above PDF files are present in the 3. declarations folder 
%
\null\thispagestyle{empty}\newpage
% ------------------- TABLE OF CONTENTS ---------------------
\selectlanguage{english}
\pagenumbering{gobble}
\tableofcontents
\thispagestyle{empty}
\newpage % IF YOU HAVE EVEN QUANTITY OD PAGES OF TOC, THEN REMOVE IT OR ADD \null\newpage FOR DOUBLE BLANK PAGE BEFORE INTRODUCTION


% -------------------- THE BODY OF THE THESIS --------------------------------

\null\thispagestyle{empty}\newpage
\pagestyle{fancy}
\pagenumbering{arabic}
\setcounter{page}{11}


\chapter{Introduction}
\markboth{}{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\section{Theoretical Background} 
TODO

\subsubsection{Interrupts}
\subsubsection{Exceptions}

\section{Scope of the Thesis} 
TODO
\section{Limitations and Assumptions}

\subsection{Minimal requirements}
\begin{itemize}
  \item avx
  \item osxsave
  \item swapgs
  \item invariant tsc
  \item HPET
  \item APIC
  \item acpi
  \item 64bit LAPIC
  \item mmu
\end{itemize}

\subsection{Known Limitations}
\label{subsec:limitations}

\begin{itemize}
  \item max process name = 128
  \item max processes = 4096
  \item max threads = 8192
\end{itemize}

Functionalities:
\begin{itemize}
  \item aaa
\end{itemize}

\section{Achieved Functionalities} 
TODO
\section{Work Division -- Code} 
TODO
\section{Work Division -- Thesis}
TODO

% ==================================================================

\chapter{Creating an Operating System from Scratch}

% Tutorial jak zrobic os krok po kroku tak zeby kazdy zrozumial pozdro

\section{Host Environment}
TODO
\subsection{Cross-Compilation Toolchain}
TODO
\subsection{Building Machinery}
TODO
\subsection{Emulation}
TODO
\subsection{Rootfs}
TODO
\subsection{Compiling Userspace Programs}
TODO
\subsection{Testing}
TODO

\section{Target Environment}
TODO
\subsection{Implementation of Libc and Libc++}
TODO
\subsection{Bootloader}
TODO
\subsection{Memory Preloading and Discovery}
TODO
\subsection{Discovering and Enabling CPU Features}
TODO
\subsection{Enabling Interrupts and Exceptions}
TODO
\subsection{Memory Management}
TODO

\subsubsection{Physical Memory Management}
TODO
\subsubsection{Virtual Memory Management}
TODO
\subsubsection{Virtual Address Space}
TODO

\subsection{Discovering External Devices and System Capabilities}
TODO

\subsubsection{Clocks}
TODO
\subsubsection{Event Clocks}
TODO

\subsection{File Systems}
TODO
\subsection{Screen Drawing}
TODO
\subsection{Scheduling}
TODO

\subsubsection{Process}
TODO
\subsubsection{Thread}
TODO
\subsubsection{Meta-Scheduler}
TODO
\subsubsection{Policies}
TODO
\subsubsection{Context Switch}
TODO
\subsubsection{Context Conversion}
TODO

\subsection{User Space}
TODO

\subsubsection{Syscalls}
TODO
\subsubsection{Libc System Headers}
TODO
\subsubsection{Conversion to User Space}
TODO


% ==================================================================

% jak to robia inni, same najwazniejsze elementy

\chapter{Analysis of Existing Solutions}

\section{Linux}
TODO

\subsection{Scheduler}
TODO
\subsection{Timing}
TODO
\subsection{Memory Management}
TODO
\subsection{System Interface}
TODO

\section{Minix}
TODO

\subsection{Scheduler}
TODO
\subsection{Timing}
TODO
\subsection{Memory Management}
TODO
\subsection{System Interface}
TODO

% ==================================================================

\chapter{Supporting Multiple Hardware Platforms} 
TODO

\section{HAL -- Hardware Abstraction Layer} 
TODO

\section{x86-64 Support} 
TODO
\subsection{Technical Debt}
TODO
\subsection{Common Pitfalls}
TODO


% ==================================================================

\chapter{Our Implementation} 
TODO

\section{Bootloader}

Before the kernel can commence execution, the underlying hardware must be brought to a known, deterministic state. Unifying this process is non-trivial, as initialization protocols differ significantly depending on the specific hardware architecture and the firmware interface (Legacy BIOS vs. UEFI). To mitigate this complexity, the operating system expects the bootloading mechanism to load the final kernel image into memory and establish a well-defined machine state, abstracting the underlying firmware details.

\subsection{x86-64 Bootloading Sequence}

Upon power-up or a hardware reset, every processor on the system bus executes a hardware reset sequence. In modern multi-core architectures, the processors engage in the Multi-Processor (MP) Initialization Protocol. This negotiation designates one core as the Bootstrap Processor (BSP), which immediately begins executing firmware code. All remaining cores, known as Application Processors (APs), enter a halt state and await a specific Startup Inter-Processor Interrupt (SIPI) to begin execution.

Once the BSP is active, its registers are hardwired to specific architecture-defined values. The CPU may optionally perform a Built-In Self-Test (BIST). Subsequently, it fetches and executes the instruction located at the physical address \texttt{0xFFFFFFF0} (the Reset Vector). This address is memory-mapped to the non-volatile system firmware.

For further details, see \cite{IntelManual-Reset}.

\subsubsection{Firmware Interfaces}

The initialization path diverges depending on the firmware implementation:

\textbf{Legacy BIOS (Basic Input/Output System)} \
Under BIOS, the CPU initializes in 16-bit Real Mode, limiting addressable memory to the first 1 MB (
$2^20$
 bytes) via segmented addressing. The BIOS executes the Power-On Self-Test (POST) and iterates through the configured boot priority list (e.g., CD-ROM, HDD, USB). It reads the first 512-byte sector of the boot device. If the last two bytes of this sector contain the boot signature \texttt{0x55AA}, the BIOS copies the sector to physical RAM address \texttt{0x7C00} and transfers execution to it.

\textbf{UEFI (Unified Extensible Firmware Interface)} \
UEFI provides a significantly more sophisticated environment. Unlike BIOS, which operates on raw disk sectors, UEFI possesses file system awareness (specifically FAT32). It searches for a specific EFI application file on the EFI System Partition (ESP), loads the executable into RAM, and executes it. Notably, UEFI transitions the processor out of 16-bit Real Mode, typically handing over control in 32-bit or 64-bit Protected Mode.

For the complete specification, refer to \cite{UEFI-Spec, UEFI-BootManager}.

\subsubsection{Multiboot2 Specification}

Regardless of whether the system utilizes BIOS or UEFI, the boot process ultimately invokes a dedicated bootloader. AlkOS utilizes a Multiboot2-compliant bootloader (such as GRUB) to normalize the execution environment. This abstraction layer ensures that the kernel remains agnostic to the underlying firmware type.

The bootloader leverages firmware services to query essential hardware configuration data, including the physical memory map and framebuffer parameters. This information is standardized into the Multiboot2 Information Structure. The bootloader loads the kernel binary and any associated modules (such as the initial ramdisk) into memory and transfers control to the kernel entry point.

At this stage, the machine state is defined as follows:
\begin{itemize}
\item \textbf{CPU Mode:} 32-bit Protected Mode.
\item \textbf{Paging:} Disabled.
\item \textbf{Interrupts:} Disabled.
\item \textbf{Registers:} \texttt{EAX} contains the Multiboot2 magic number (\texttt{0x36d76289}), and \texttt{EBX} contains the physical address of the Multiboot2 information structure.
\end{itemize}

See \cite{Multiboot2-Spec} for the full specification.

While standardized, this state is insufficient for the immediate execution of the AlkOS kernel. The kernel requires a 64-bit Long Mode environment, access to the higher-half of the virtual memory space via paging, and a valid stack for C++ execution. Furthermore, advanced CPU features (such as floating-point units or AVX) remain disabled. Consequently, the boot process requires intermediate initialization stages - \textbf{Loader32} and \textbf{Loader64} - to bridge the gap between the Multiboot2 state and the kernel's requirements. \todo[inline]{Split this between Our Solution and How to implement os (generic)}
\subsubsection{Loader32}
TODO
\subsubsection{Loader64}
TODO

\section{Assumptions}
TODO
\section{Memory Management}
\label{sec:memory}
TODO

\section{Interrupts}
\label{sec:interrupts}

Interrupt handling is a critical component of any operating system. Without interrupts, the system would rely on manually polling devices or checking states, which is inefficient and wasteful of resources. Furthermore, interrupts enable the system to be significantly more responsive. For example, when a keyboard key is pressed, the operating system may need to immediately switch execution to the thread responsible for consuming the input, rather than waiting for the current task to finish. More broadly, the OS utilizes the interrupt mechanism to perform context switches. If a task exceeds its allocated execution time, timing devices such as the LAPIC Timer trigger an interrupt, allowing the scheduler to preempt the current task and grant CPU time to others.

\subsection{Interrupt Types}

On most platforms, interrupts fall into three general classes:

\begin{itemize}
\item \textbf{Exceptions} -- Generated by the CPU to inform the kernel about specific conditions requiring immediate attention, such as Page Faults, Division by Zero, or invalid instruction operands.
\item \textbf{Hardware Interrupts} -- Generated by external devices (e.g., Timers, Keyboard, Disk Controller) to efficiently communicate with the kernel without the need for polling.
\item \textbf{Software Interrupts} -- Initiated by software instructions. For example, on the x86-64 architecture, the instruction \texttt{INT 0x80} triggers an interrupt with the vector number \texttt{0x80}.
\end{itemize}

\subsection{x86-64 Interrupts}

\subsubsection{Interrupt Handling}
On the x86-64 architecture, every interrupt is assigned a unique number (vector) which maps directly to an entry in the \textbf{Interrupt Descriptor Table} (IDT) \cite{IntelManual-Interrupts}. This table contains instructions for the CPU on how to react to specific interrupts. The entry layout is as follows:

\begin{lstlisting}[caption={IDT Entry Layout}, label={lst:idtEntry}]
  enum class IdtPrivilegeLevel : u8 { kRing0 = 0, kRing1 = 1, kRing2 = 2, kRing3 = 3 };

  struct PACK IdtEntryFlags {
      IdtGateType type : 4;
      u8 zero : 1;
      IdtPrivilegeLevel dpl : 2;
      u8 present : 1;
  };
  struct PACK IdtEntry {
      u16 isr_low;    // The lower 16 bits of the ISR's address
      u16 kernel_cs;  // The GDT segment selector that the CPU
                      //  will load into CS before calling the ISR
      u8 ist;         // The IST in the TSS that the CPU will load into RSP
      IdtEntryFlags attributes;  // Type and attributes
      u16 isr_mid;  // The higher 16 bits of the lower 32 bits of the ISR's address
      u32 isr_high; // The higher 32 bits of the ISR's address
      u32 reserved; // Set to zero
  };
\end{lstlisting}

The most critical component of the IDT entry is the address of the function to be invoked (split into \texttt{isr\_low}, \texttt{isr\_mid}, and \texttt{isr\_high}). Another important field is \texttt{kernel\_cs}, which specifies the code segment \cite{IntelManual-Segments} loaded before executing the handler. In x86-64, there are four privilege levels (Rings). We assume the kernel always operates in Ring 0 (the most privileged level). Therefore, the Ring 0 kernel code segment is always written to this field. Conversely, the \texttt{IdtPrivilegeLevel dpl} field specifies the minimal privilege level required to trigger the interrupt via software, which is essential for implementing system calls (syscalls) invoked from userspace.

\subsubsection{Interrupt Service Routines}

Functions handling interrupts differ significantly from standard functions generated by the compiler. When the CPU calls an interrupt handler, it first switches the stack pointer to the kernel stack if a privilege level change occurs (e.g., Ring 3 to Ring 0). This transition is managed via the Task State Segment (TSS) mechanism (for details, refer to \cite{osdev-tss}). The CPU then changes the code segment as specified in the \textbf{IDT entry} (Listing \ref{lst:idtEntry}). Subsequently, it pushes the state of the interrupted procedure onto the stack.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
      node distance=0cm,
      start chain=going below,
      stacknode/.style={
          draw, 
          minimum width=5cm, 
          minimum height=1cm, 
          outer sep=0pt, 
          font=\ttfamily
      },
      labelnode/.style={
          minimum height=1cm,
          font=\footnotesize\sffamily,
          anchor=east
      }
  ]
  
  \node (highmem) at (0, 1) {Higher address (High Memory)};
  \draw[->] (highmem) -- (0, 0.2);

  \node [stacknode, on chain, fill=gray!10] (ss) {Stack Segment (SS)};
  \node [stacknode, on chain, fill=gray!10] (rsp) {Stack Pointer (RSP)};
  \node [stacknode, on chain, fill=gray!10] (rflags) {RFLAGS};
  \node [stacknode, on chain, fill=gray!10] (cs) {Code Segment (CS)};
  \node [stacknode, on chain, fill=gray!10] (rip) {Instruction Pointer (RIP)};
  \node [stacknode, on chain, fill=gray!10] (error) {Error Code (optional)};
  \draw[<-, thick, red] (error.east) -- ++(1.5,0) node[right, text=red] {Current RSP};

  \node [below=0.5cm of error] (lowmem) {Lower address (Low Memory)};
  \draw[->] (lowmem.north) -- (error.south);

  \end{tikzpicture}
  \caption{Interrupt Service Routine stack layout on entry}
  \label{fig:stackframe}
\end{figure}

The layout illustrated in Figure \ref{fig:stackframe} is known as the \textbf{Interrupt Frame}. This structure is fundamental to the kernel architecture, serving as the basis for context switching, context conversion, and jumping to userspace (Ring 3). A key distinction is that an \textbf{ISR} must return using the special instruction \textbf{IRETQ} \cite{IntelManual-Interrupts}, which reverses the actions described above, including restoring the privilege level and code segment. 

A significant challenge with standard compiler-generated functions is that they may modify the stack frame (prologue/epilogue) in ways that interfere with the hardware-defined layout. To maintain full control and prevent stack corruption, we implement assembly wrappers. These wrappers perform the necessary architecture-specific actions before invoking the architecture-agnostic interrupt handling code defined in C++.

\begin{lstlisting}[style=nasmstyle, caption={Assembly ISR wrapper}, label={lst:isr_asm}]
%macro context_switch_if_needed 0
  cmp rax, 0
  je .done                         ; Omit context switch if there is no need

  mov r13, rax                     ; save next TCB

  mov rdi, r13
  mov rsi, rsp
  call cdecl_ContextSwitchOnInterrupt

  mov rsp, [r13+Thread.kernel_stack]   ; Change the stack
.done:

  load_user_gs_if_needed

  pop_all_regs                    ; Restore registers.
  add rsp, _all_reg_size          ; Deallocate register save space.
  add rsp, 8                      ; Pop error code.
  iretq
%endmacro

; Macro for hardware or software interrupts.
; Calls a handler with the signature 'void handler(u16 lirq, void* frame)'.
%macro interrupt_wrapper 3 ; %1: Logical IRQ, %2: idt idx %3: C handler function
isr_wrapper_%+%2:
    push 0                          ; Push a dummy error code for unification.
    sub rsp, _all_reg_size          ; Allocate space for saving registers.
    push_all_regs                   ; Save registers.

    load_kernel_gs_if_needed

    cld                         ; Clear direction flag for string operations.
    mov rdi, %1                 ; Arg1: mapped lirq number.
    mov rsi, rsp                ; Arg2: pointer to stack frame.
    call %3                     ; Call the specific ISR handler.

    context_switch_if_needed
%endmacro
\end{lstlisting}

\subsubsection{Synchronization}

Since an interrupt can potentially trigger a context switch, synchronization is crucial. This applies to both kernel-space threads at any moment of their lifetime and userspace programs executing system calls. It would be catastrophic if a timer interrupt forced a context switch while the kernel was in the middle of updating scheduler structures or memory tables. Therefore, even on a single-core system, synchronization must be enforced. This is achieved by disabling hardware interrupts (using \textbf{CLI} and \textbf{STI} instructions on x86-64) during critical sections.

\subsection{Unified Interrupt Frame}
\label{subsec:unifiedFrame}

To simplify interrupt handling, we introduced a unified frame structure based on the hardware Interrupt Frame (Figure \ref{fig:stackframe}). Since the state of a thread must be preserved before a context switch, all general-purpose registers must be saved. To achieve this efficiently, these registers are pushed onto the stack by the assembly wrapper, creating the \textbf{Unified Interrupt Frame}.

The x86-64 architecture introduces an inconsistency in the stack layout depending on the interrupt source. Certain exceptions, such as Page Faults (vector 14) or General Protection Faults (vector 13), automatically push an error code onto the stack by the CPU. Hardware interrupts and other exceptions do not. To use a single, unified C++ structure for all interrupt handling (\texttt{IsrErrorStackFrame}), the assembly entry wrappers must normalize the stack. For vectors that do not produce a hardware error code, the wrapper explicitly pushes a dummy value (typically 0) before saving the general-purpose registers (as seen in Listing \ref{lst:isr_asm}). This ensures that the stack pointer is always aligned correctly and points to a uniform structure when the C++ handler is invoked.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
      node distance=0cm,
      start chain=going below,
      stacknode/.style={
          draw, 
          minimum width=5cm, 
          minimum height=1cm, 
          outer sep=0pt, 
          font=\ttfamily
      },
      labelnode/.style={
          minimum height=1cm,
          font=\footnotesize\sffamily,
          anchor=east
      }
  ]
  
  \node (highmem) at (0, 1) {Higher address (High Memory)};
  \draw[->] (highmem) -- (0, 0.2);

  \node [stacknode, on chain, fill=gray!10] (ss) {Stack Segment (SS)};
  \node [stacknode, on chain, fill=gray!10] (old_rsp) {Old Stack Pointer (RSP)};
  \node [stacknode, on chain, fill=gray!10] (rflags) {RFLAGS};
  \node [stacknode, on chain, fill=gray!10] (cs) {Code Segment (CS)};
  \node [stacknode, on chain, fill=gray!10] (rip) {Instruction Pointer (RIP)};
  \node [stacknode, on chain, fill=gray!10] (error) {Error Code (or Dummy)};
  \node [stacknode, on chain, fill=gray!10] (genregs) {General Registers (RDI, RSI, ...)};
  \node [stacknode, on chain, fill=gray!10] (rax) {Last Saved Register};
  
  \draw[<-, thick, red] (rax.east) -- ++(1.5,0) node[right, text=red] {RSP (New Stack Pointer)};

  \node [below=0.5cm of rax] (lowmem) {Lower address (Low Memory)};
  \draw[->] (lowmem.north) -- (rax.south);

  \end{tikzpicture}
  \caption{Unified Interrupt Frame (IsrErrorStackFrame)}
  \label{fig:unifiedstackframe}
\end{figure}

\subsection{Context Switch}

As previously mentioned, the OS utilizes the interrupt mechanism to perform task switching. The interrupt mechanism handles most of the necessary context-switching operations automatically:
\begin{itemize}
\item Manages ring permissions (automatically swapping code and stack segments).
\item Automatically swaps the stack from user stack to kernel stack (using the TSS).
\item Restores \textbf{RFLAGS} (which includes the \textbf{interrupt flag} responsible for enabling/disabling hardware interrupts).
\item Jumps back to the code address pointed to by \textbf{RIP}.
\end{itemize}

To switch contexts, we must ensure the current thread's state is preserved in a \textbf{Unified Interrupt Frame} (Figure \ref{fig:unifiedstackframe}) on its kernel stack. Additionally, a valid frame must exist for the target thread. If a thread has run previously, it will have saved its frame naturally during its last preemption. However, for a new thread that has never executed, this frame must be constructed manually. 

We assume that all threads begin execution in kernel space before eventually jumping to user space. Since all interrupt handling occurs within the kernel, the interrupt frame always resides on the kernel stack. Therefore, we can initialize the kernel stack of the new thread with a fabricated frame before the context switch. The initialization procedure is as follows:

\begin{lstlisting}[caption={Thread stack initialization}, label={lst:threadStack}]
void InitializeThreadStack(void **stack, const Sched::Task &task)
{
    /* NOTE: Thread entry always starts in Kernel Code */
    auto stack_top = static_cast<byte *>(*stack) - sizeof(IsrErrorStackFrame);
    auto frame     = reinterpret_cast<IsrErrorStackFrame *>(stack_top);

    memset(stack_top, 0, sizeof(IsrErrorStackFrame));

    /* Initialize IsrErrorStackFrame (Hardware Part + Error Code) */
    frame->isr_stack_frame.rip    = reinterpret_cast<u64>(task.func);
    frame->error_code             = 0; // Dummy error code
    frame->isr_stack_frame.cs     = static_cast<u64>(cpu::GDT::kKernelCodeSelector);
    frame->isr_stack_frame.rflags = kInitialRFlags;
    frame->isr_stack_frame.rsp    = reinterpret_cast<u64>(*stack);
    frame->isr_stack_frame.ss     = static_cast<u64>(cpu::GDT::kKernelDataSelector);

    /* Initialize function arguments (Software Part / Registers) */
    if (task.args_count > 0) {
        frame->registers.rdi = task.args[0];
    }

    // ... other args

    if (task.args_count > 5) {
        frame->registers.r9 = task.args[5];
    }

    /* Save adjusted stack address */
    *stack = reinterpret_cast<void *>(stack_top);
}
\end{lstlisting}

With both stack frames prepared, the context switch logic is straightforward: swap the \textbf{RSP} (current stack pointer) to the kernel stack of the target thread and execute the \textbf{IRETQ} instruction. This instruction restores the state and resumes execution, as demonstrated in the \textbf{context\_switch\_if\_needed} macro (Listing \ref{lst:isr_asm}).

\subsection{Jumping to Userspace}

Transitioning to userspace is performed similarly to a thread context switch. We construct an artificial interrupt frame, but in this case, the code segment and stack segment within the frame are set to the user space selectors, and the stack pointer is set to the user space stack. The implementation is shown below:

\begin{lstlisting}[caption={Userspace Jump C++ code}, label={lst:userSpaceJump}]
extern "C" void cdecl_JumpToUserSpaceEntry(void *addr, IsrStackFrame *frame)
{
    ASSERT_NOT_NULL(addr);
    ASSERT_NOT_NULL(frame);
    ASSERT_NOT_NULL(hardware::GetCoreLocalTcb());

    auto thread          = hardware::GetCoreLocalTcb();
    thread->kernel_stack = thread->kernel_stack_bottom; // reset kernel stack

    frame->rip    = reinterpret_cast<u64>(addr);
    frame->cs     = static_cast<u64>(cpu::GDT::kUserCodeSelector);
    frame->rflags = static_cast<u64>(kInitialRFlags);
    frame->rsp    = reinterpret_cast<u64>(thread->user_stack_bottom);
    frame->ss     = static_cast<u64>(cpu::GDT::kUserDataSelector);

    const u64 t            = TimingModule::Get().GetSystemTime().ReadLifeTimeNs();
    thread->kernel_time_ns = t - thread->timestamp;
    thread->timestamp      = t;

    SetThreadGs(thread);
    __asm__ volatile("swapgs" ::: "memory");
}
\end{lstlisting}

\begin{lstlisting}[style=nasmstyle, caption={Userspace Jump NASM code}, label={lst:userSpaceJumpNasm}]
; c_decl
; void JumpToUserSpace(void (*func)(), void* arg)
;   RDI = func
;   RSI = arg
; Note: Caller is responsible for ensuring proper environment before calling (disabling IRQs)
JumpToUserSpace:
    sub rsp, _jump_userspace_stack_space
    push rsi
    ; aligned properly

    mov rsi, rsp
    add rsi, 8
    call cdecl_JumpToUserSpaceEntry

    xor rax, rax
    mov rax, _user_data_selector
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    pop rsi
    mov rdi, rsi ; prepare void* arg for func if needed
    iretq
\end{lstlisting}

\subsection{Interrupts Hardware Abstraction}

To maintain architectural independence, the Interrupt Table is abstracted. Upon any interrupt, control is passed to the \textbf{Logical Interrupt Table (LIT)}, which is responsible for executing the necessary actions common to all interrupts. The architecture-specific code establishes the mapping between the hardware interrupts and the logical interrupt table, from that point forward, interrupt management is handled entirely by the LIT. Responsibilities of the LIT include:

\begin{itemize}
\item Managing interrupt handlers, allowing the kernel to modify interrupt responses dynamically.
\item Tracking interrupt nesting levels.
\item Collecting statistics, such as interrupt counts per thread, kernel time, and user space time.
\item Interacting with hardware interrupt drivers such as the \textbf{PIC} or \textbf{APIC}.
\item Masking (blocking) individual interrupts.
\end{itemize}

The LIT handling procedures may return a pointer to the next thread scheduled for execution. If such a pointer is returned, the hardware wrapper performs the context switch upon exit. This mechanism enables the system to react rapidly to state changes or preempt the current thread via a timer interrupt.
\section{Timing}
\label{sec:timing}

Prior to the implementation of the Scheduler, and alongside functional memory management and interrupt handling, it was necessary to establish the infrastructure and drivers for timing mechanisms. This includes devices capable of measuring the system's uptime, referred to as \textbf{Clocks}. Additionally, the system requires devices capable of generating interrupts at specific intervals. These are essential for preempting the currently executing thread if it fails to yield the CPU voluntarily, thereby ensuring fair scheduling. Such devices are referred to as \textbf{Event Clocks}. To unify the timing subsystem, all devices and mechanisms rely on nanoseconds as the fundamental unit of time abstraction.

\subsection{Infrastructure}

The architecture-specific code is responsible for detecting available hardware and registering it within the central timing infrastructure, specifically the \textbf{ClockRegistry} and \textbf{EventClockRegistry}. Subsequently, architecture-agnostic components, such as the \textbf{ACPI} subsystem, may register additional clocks by parsing system description tables. Finally, the architecture-defined functions \texttt{hal::PickSystemClockSource()} and \texttt{hal::PickSystemEventClockSource()} are invoked during the initialization of the timing module to select the optimal sources for each purpose. The infrastructure allows the scheduler to implement either a tick-based or a tickless strategy.

\subsection{Clocks}

Clock Drivers are defined by the following structure:

\begin{lstlisting}[caption={Clock Driver Structure}, label={lst:clockDriver}]
struct alignas(arch::kCacheLineSizeBytes) ClockRegistryEntry : data_structures::RegistryEntry {
  /* Clock numbers */
  u64 frequency_kHz; // Frequency in kHz
  u64 ns_uncertainty_margin_per_sec;  
    // Uncertainty margin in femtoseconds per second
  u64 clock_numerator; // For conversion to nanoseconds, this is the numerator
  u64 clock_denominator; // For conversion to nanoseconds, this is the denominator

  /* Callbacks */
  u64 (*read)(ClockRegistryEntry *);
  bool (*enable_device)(ClockRegistryEntry *);
  bool (*disable_device)(ClockRegistryEntry *);
  void (*stop_counter)(ClockRegistryEntry *);
  void (*resume_counter)(ClockRegistryEntry *);

  /* Own data */
  void *own_data;
};
\end{lstlisting}

For the x86-64 architecture, clock selection is prioritized based on availability and precision in the following order: TSC > HPET > RTC > PIT. Currently, support is implemented only for the TSC and HPET drivers.

\subsubsection{TSC}
The Time Stamp Counter (TSC) is the optimal clock source due to its high precision and core-locality. Accessing the TSC involves reading a CPU register, which requires only a few cycles, unlike external clocks that may require hundreds. However, the TSC has historical limitations. On older processors, the counter's frequency was tied to the core frequency. Consequently, frequency scaling (throttling) caused the time measurement to drift, rendering it unreliable. Modern Intel processors introduced the Invariant TSC, which ensures a constant frequency regardless of the core's power state. Another limitation is that on certain CPUs, the TSC frequency is not explicitly known and must be measured against a known reference. For this purpose, the system utilizes the HPET, which serves as the minimal hardware requirement for reliable calibration (see \cite{IntelManual-TSC}).

\subsubsection{HPET}
The High Precision Event Timer (HPET) also offers high precision and is generally more stable than the TSC on older hardware. However, it is an external device mapped via Memory-Mapped I/O (MMIO). As a result, accessing the HPET is significantly slower than reading the TSC, potentially taking up to 1000 cycles per read. Due to this performance overhead, the HPET is designated as the secondary choice. It is primarily utilized for calibrating other clocks rather than for frequent timekeeping operations.

\subsection{Event Clocks}

Event Clock Drivers are defined by the following structure:

\begin{lstlisting}[caption={Event Clock Driver Structure}, label={lst:eventClockDriver}]
struct PACK EventClockFlags {
    bool IsCoreLocal : 1;
    u32 padding : 31;
};
static_assert(sizeof(EventClockFlags) == sizeof(u32));

enum class EventClockState : u8 {
    kDisabled = 0,  // Clock is disabled
    kPeriodic,      // Clock is in periodic mode
    kOneshot,       // Clock is in oneshot mode
    kOneshotIdle,   // Clock is in oneshot mode but no event is scheduled
    klast,
};

struct alignas(arch::kCacheLineSizeBytes) EventClockRegistryEntry : data_structures::RegistryEntry {
    /* Clock numbers */
    u64 min_next_event_time_ns;  // Minimum time for the next event in nanoseconds

    /* Clock specific data */
    EventClockFlags flags;     // Features of the event clock, e.g., core-local
    CoreMask supported_cores;  // Cores that support this event clock

    /* infra data */
    u64 next_event_time_ns;  // Time for the next event in nanoseconds
    EventClockState state;   // Current state of the clock

    /* Driver data */
    void *own_data;  // Pointer to the clock's own data, used for callback

    /* callbacks */
    struct callbacks {
        // Callback to set next event time
        u32 (*next_event)(EventClockRegistryEntry *, u64);  
        // Callback to set clock state
        u32 (*set_oneshot)(EventClockRegistryEntry *);
        // Callback to set clock state
        u32 (*set_periodic)(EventClockRegistryEntry *);     
        void (*on_entry)(EventClockRegistryEntry *);        // optional
        void (*on_exit)(EventClockRegistryEntry *);         // optional
    } cbs;
};
\end{lstlisting}

For x86-64, the selection of event clocks is based on the following priority order: LAPIC Timer > HPET > PIT. Currently, only the LAPIC Timer is supported as it provides the core-local interrupt capabilities required for efficient scheduling.

\subsubsection{LAPIC Timer}
Similar to the TSC, the LAPIC Timer is local to the processor core, ensuring extremely low-latency access to its registers. A significant advantage of this architecture is that each core possesses an independent timer, which eliminates the need for shared resource management or synchronization between cores. However, like the TSC, the LAPIC Timer operates at a frequency derived from the CPU bus or core frequency, which is not standard across various CPUs. Consequently, it requires calibration against a reference clock, for which the HPET is utilized.

\section{File System}
\label{section:fs}

The file system is a fundamental part of any operating system, providing mechanisms to store, access, and manage data on storage devices. We have designed a unified abstraction layer known as the Virtual File System (VFS). The VFS abstracts the underlying implementation details of specific file systems, providing the kernel and user space with an API for operations such as reading, writing, creating, moving, and deleting files and directories.

\subsection{VFS}

The VFS enables the operating system to interact with various file system types (e.g., FAT12, FAT16, FAT32) through a uniform interface, eliminating the need for the kernel to understand the specific implementation details. This modularity is achieved through a combination of compile-time enforced interfaces (Concepts) and a runtime dispatch mechanism.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
      node distance=1.5cm,
      block/.style={
        rectangle, draw, fill=gray!10,
        text width=5cm, text centered,
        rounded corners, minimum height=1cm
      },
      component/.style={
        rectangle, draw, fill=gray!10,
        text width=5cm, text centered,
        minimum height=1cm
      },
      interface/.style={
        rectangle, draw, dashed, fill=gray!10,
        text width=5cm, text centered,
        minimum height=1cm
      },
      storage/.style={
        cylinder, draw, fill=gray!10,
        shape aspect=0.5,
        text width=4.5cm, text centered,
        minimum height=1cm
      },
      arrow/.style={-Latex, thick}
  ]

  \node (user_process) [block] {User Process};
  \node (fd_manager) [block, below=of user_process] {File Descriptor Manager};
  \node (vfs_module) [block, below=of fd_manager] {VFS Module};
  \node (fs_interface) [interface, below=of vfs_module] {Filesystem Interface};
  \node (fs_driver) [component, below=of fs_interface] {File System Driver \\ (FAT12 / FAT16 / FAT32)};
  \node (vfs_io) [interface, below=of fs_driver] {VFS I/O Interface};
  \node (storage_device) [storage, below=of vfs_io] {Storage Device \\ (RAM, Disk, Network)};

  \draw [arrow] (user_process) -- (fd_manager) node [midway, right] {Syscalls};
  \draw [arrow] (fd_manager) -- (vfs_module) node [midway, right] {File Operations};
  \draw [arrow] (vfs_module) -- (fs_interface) node [midway, right] {Dispatch};
  \draw [arrow] (fs_interface) -- (fs_driver) node [midway, right] {Implements};
  \draw [arrow] (fs_driver) -- (vfs_io) node [midway, right] {Uses};
  \draw [arrow] (vfs_io) -- (storage_device) node [midway, right] {I/O Operations};

  \end{tikzpicture}
  \caption{High-level VFS Architecture}
  \label{fig:vfs_architecture}
\end{figure}

As illustrated in Figure \ref{fig:vfs_architecture}, the VFS architecture is composed of four primary layers:

\begin{itemize}
\item \textbf{VFS Module}: The central orchestrator for path resolution and operation delegation.
\item \textbf{Filesystem Interface}: A struct containing function pointers that abstract specific driver operations.
\item \textbf{Filesystem Driver}: The concrete implementation of a specific file system format.
\item \textbf{VFS I/O Interface}: An abstraction for block-level data access.
\end{itemize}

The following subsections describe each of these components in detail.

\subsubsection*{VFS Module}

The VFS module serves as the entry point for all file operations and is responsible for managing file system mounts. It exposes the internal kernel API for operations such as opening, reading, and writing files. The module's primary responsibility is to translate these requests into calls to the appropriate filesystem instance based on the provided file path and the currently registered mount points.

When a VFS operation (e.g., \texttt{CreateFile}) is invoked, the module executes the following sequence:
\begin{enumerate}
    \item \textbf{Find Mount Point}: The system utilizes a \textbf{crit-bit tree} \cite{critbit} to efficiently locate the longest prefix match for the given path among all registered mount points. This step identifies the specific filesystem driver responsible for handling the operation.
    \item \textbf{Check Permissions}: The module validates the operation against the mount point options (e.g., ensuring write operations are not attempted on read-only mounts).
    \item \textbf{Path Translation}: The absolute system path is translated into a path relative to the mount point root.
    \item \textbf{Delegation}: The operation is delegated to the corresponding method of the specific filesystem driver.
\end{enumerate}

\begin{lstlisting}[caption={VfsModule CreateFile Implementation}, label={lst:vfsModuleCreateFile}]
Result<> internal::VfsModule::CreateFile(const Path &path)
{
    auto mount_result = FindMountPoint(path);
    RET_UNEXPECTED_IF_ERR(mount_result);

    MountPoint *mount = mount_result.value();

    RET_UNEXPECTED_IF(mount->options.read_only, VfsError::kReadOnly);

    Path relative_path = GetRelativePath_(path, mount->path);
    return mount->fs.CreateFile(relative_path);
}
\end{lstlisting}

\subsubsection*{Filesystem Interface}

The \texttt{vfs::Filesystem} struct acts as a uniform interface that all concrete filesystem drivers must expose. It contains function pointers for various file and directory manipulations, alongside metadata about the filesystem. Each function pointer accepts a \texttt{void* ctx} argument, allowing the generic VFS layer to pass the concrete driver instance.

\begin{lstlisting}[caption={vfs::Filesystem Structure}, label={lst:vfsFilesystem}]
struct Filesystem {
    struct Operations {
        // File operations
        Result<> (*create_file)(void *ctx, const Path &path);
        Result<size_t> (*read_file)(
            void *ctx, const Path &path, void *buffer, size_t size, size_t offset
        );
        Result<size_t> (*write_file)(
            void *ctx, const Path &path, const void *buffer, size_t size, size_t offset
        );
        Result<> (*delete_file)(void *ctx, const Path &path);
        // ... (additional operations omitted for brevity)
    };

    struct Info {
        Type type;
        const char *name;  // e.g., "FAT32", "FAT16"
    };
    
    Filesystem() = delete;
    explicit Filesystem(void *context, const Operations &operations, const Info &info)
    : context_(context), ops_(operations), info_(info) {}

private:
    void *context_;  // Pointer to the concrete driver instance
    Operations ops_;
    Info info_;
};
\end{lstlisting}

\subsubsection*{Filesystem Driver}

Each filesystem driver implements the logic required for a specific filesystem type (e.g., FAT12, FAT16, FAT32). The driver interprets the raw data structures on the storage device and performs the requested operations. For instance, the FAT32 driver handles the manipulation of the File Allocation Table, directory entries, and cluster chains according to the FAT32 specification (for details, see \cite{fat-spec}).

To implement these drivers efficiently, we employ the Curiously Recurring Template Pattern (CRTP) \cite{crtp}. Each driver class inherits from a templated base class that provides common functionality, while the derived class implements format-specific details. This approach enables static polymorphism, reducing the runtime overhead typically associated with virtual function calls.

\begin{lstlisting}[caption={FAT Driver CRTP Base Class}, label={lst:fatCrtp}]
template <template <typename> typename T, typename IO>
class Fat
{
    using ImplT  = T<IO>;
    using Traits = FatTraits<T, IO>;

protected:
    // ... common FAT structures, validation, and operations

public:
    NODISCARD Filesystem GetFilesystem()
    {
        return Filesystem(
            this, // 'this' pointer is passed as the context
            Filesystem::Operations{
                .create_file = &Fat::CreateFileCallback_,
                // ...
            },
            Filesystem::Info{
                .type = ImplT::kFsType,
                .name = ImplT::kFsName,
            }
        );
    }

private:
    FAST_CALL Result<> CreateFileCallback_(void *ctx, const Path &path)
    {
        return static_cast<Fat *>(ctx)->CreateFile(path);
    }
    // ...
};
\end{lstlisting}

Each \texttt{Fat} derivative implements its specific logic (e.g., Getting FAT entries differs between FAT12 and FAT32/16) and provides a static \texttt{IsValid(IO \&io)} method to probe whether a given I/O device contains a valid instance of that filesystem.

\begin{lstlisting}[caption={Fat12 GetFATEntry Implementation}, label={lst:fat12GetFatEntry}]
    NODISCARD FORCE_INLINE_F ClusterNumT GetFATEntry_(ClusterNumT cluster) const
    {
        ASSERT_LT(
            cluster, BaseT::cluster_count_ + BaseT::kFirstClusterNumber,
            "Cluster number out of range"
        );
        const size_t fat_offset = cluster + (cluster / 2);
        const size_t sector_number =
            BaseT::fat_region_.start + (fat_offset / boot_sector_.fat.bytes_per_sector);
        const size_t sector_offset = fat_offset % boot_sector_.fat.bytes_per_sector;

        // Load 2 sectors if entry spans two sectors
        size_t count =
            (sector_offset == static_cast<size_t>(boot_sector_.fat.bytes_per_sector - 1)) ? 2 : 1;
        auto range = BaseT::io_.ReadRange({sector_number, count});
        if ((cluster % 2) == 0) {  // Even cluster
            return internal::get<ClusterNumT>(range, sector_offset) & kClusterMask;
        } else {
            return internal::get<ClusterNumT>(range, sector_offset) >> 4;
        }
    }
\end{lstlisting}

\subsubsection*{VFS Interfaces and Concepts}

To enforce architectural compliance at compile time, we utilize C++20 Concepts to define strict contracts for both filesystem drivers and low-level storage operations.

The \texttt{VFSInterface} concept (Listing \ref{lst:vfsInterfaceConcept}) mandates that any compliant driver class must provide a constructor accepting an I/O backend, a static method to validate the filesystem signature on the storage medium, and a method to retrieve the runtime function table.

\begin{lstlisting}[caption={VFSInterface Concept Definition}, label={lst:vfsInterfaceConcept}]
template <template <typename> typename T, typename IO>
concept VFSInterface = VFSIO<IO> and requires(T<IO> fs, IO io) {
    T<IO>(io);
    { T<IO>::IsValid(io) } -> std::same_as<bool>;
    { fs.GetFilesystem() } -> std::same_as<Filesystem>;
};
\end{lstlisting}

The VFS I/O interface abstracts low-level data access. The \texttt{VFSIO} concept (Listing \ref{lst:vfsioConcept}) establishes a contract for block-based input and output. By adhering to this concept, filesystem drivers remain decoupled from the underlying hardware, enabling seamless interaction with diverse storage backends --- such as RAM disks, physical partitions, or network storage --- without requiring implementation changes.

\begin{lstlisting}[caption={VFSIO Concept Definition}, label={lst:vfsioConcept}]
template <typename IO>
concept VFSIO =
    requires(IO io, size_t offset, io::SectorRange range, std::span<const byte> data, size_t size) {
        { io.ReadRange(range) } -> std::same_as<std::span<byte>>;
        { io.ReadSector(offset) } -> std::same_as<std::span<byte>>;
        { io.WriteRange(range, data) } -> std::same_as<void>;
        { io.WriteSector(offset, data) } -> std::same_as<void>;
        { io.GetSectorSize() } -> std::same_as<size_t>;
    };
\end{lstlisting}

\subsection{File Descriptors}

The file descriptor system provides a hierarchical structure to handle file I/O operations initiated by user processes. This design tracks open files, maintains current read/write offsets, and enforces access rights.

\begin{figure}[htbp]
  \centering
  \includesvg[width=\textwidth]{res/fd-diagram.svg}
  \caption{File Descriptor Design}
  \label{fig:fd_architecture}
\end{figure}

As depicted in Figure \ref{fig:fd_architecture}, the system comprises three main tables:

\subsubsection*{FdTable (Per-Process)}
Each process maintains its own \texttt{FdTable}, which is an array mapping integer file descriptors to \texttt{RefPtr<OpenFileEntry>} objects.

\begin{lstlisting}[caption={FdTable Allocation}, label={lst:fdTableAllocate}]
FdResult<fd_t> FdTable::Allocate(data_structures::RefPtr<OpenFileEntry> global_entry)
{
    std::lock_guard lock(lock_);
    for (size_t i = 0; i < kMaxFdsPerProcess; ++i) {
        if (entries_[i] == nullptr) {
            entries_[i] = std::move(global_entry);
            ++count_;
            return static_cast<fd_t>(i);
        }
    }
    return std::unexpected(FdError::kFdTableFull);
}
\end{lstlisting}

\subsubsection*{OpenFileTable (Global)}

The \texttt{OpenFileTable} is a system-wide pool of \texttt{OpenFileEntry} objects. Each entry represents a unique "open" instance of a resource (file or pipe), maintaining dynamic state such as the current read/write offset, access flags (e.g., Read/Write), and a handle to the underlying resource. Multiple file descriptors from different processes can point to the same \texttt{OpenFileEntry}, allowing them to share the cursor position.

\begin{lstlisting}[caption={OpenFileTable Creation}, label={lst:openFileTableOpenFile}]
FdResult<data_structures::RefPtr<OpenFileEntry>> OpenFileTable::OpenFile(File *file, OpenMode flags)
{
    RET_UNEXPECTED_IF(file == nullptr, FdError::kInvalidArgument);

    std::lock_guard lock(lock_);

    const size_t idx = entries_.Allocate();
    RET_UNEXPECTED_IF(idx == std::numeric_limits<size_t>::max(), FdError::kIoError);

    OpenFileEntry *entry = entries_.Get(idx);
    ASSERT_NOT_NULL(entry);

    new (entry) OpenFileEntry();
    entry->pool_idx_ = idx;

    entry->handle    = FileHandle::Wrap(file);
    entry->flags     = static_cast<u32>(flags);
    entry->offset    = 0;
    entry->is_append = HasMode(flags, OpenMode::kAppend);
    ++count_;

    return data_structures::RefPtr(entry);
}
\end{lstlisting}

The \texttt{FileHandle} utilizes a \texttt{NonOwningTaggedPtr} to hold either a pointer to a \texttt{File} object or a \texttt{Pipe} instance, enabling the \texttt{OpenFileEntry} to manage both cases seamlessly.

\subsubsection*{FileTable (Global)}
The \texttt{FileTable} manages unique \texttt{File} objects system-wide. Each \texttt{File} object acts as the in-memory representation of a physical file on the filesystem, storing static attributes such as the path and file size. This ensures that a file on the VFS has a single representation in memory, regardless of how many times it has been opened.

\begin{lstlisting}[caption={FileTable GetOrCreate}, label={lst:fileTableGetOrCreate}]
FdResult<data_structures::RefPtr<File>> FileTable::GetOrCreate(const vfs::Path &path)
{
    RET_UNEXPECTED_IF(path.IsEmpty(), FdError::kInvalidArgument);

    File *existing = Find(path);
    if (existing != nullptr) {
        return data_structures::RefPtr(existing, false);
    }

    const size_t idx = files_.Allocate();
    RET_UNEXPECTED_IF(idx == std::numeric_limits<size_t>::max(), FdError::kIoError);

    File *file = files_.Get(idx);
    ASSERT_NOT_NULL(file);

    new (file) File();
    file->pool_idx_ = idx;

    file->size = 0;
    file->mode = 0;
    file->path = path;
    ++count_;

    return data_structures::RefPtr(file);
}
\end{lstlisting}

\subsubsection*{FdManager}
The \texttt{FdManager} integrates these three tables and exposes file descriptor operations (e.g., \texttt{Open}, \texttt{Close}, \texttt{Read}). When a process requests to open a file, the \texttt{FdManager} coordinates the interaction: it validates existence via the VFS module, retrieves the \texttt{File} object, creates a new entry in the \texttt{OpenFileTable}, and finally assigns a file descriptor in the process's \texttt{FdTable}.

\begin{lstlisting}[caption={FdManager Open Implementation}, label={lst:fdManagerOpen}]
FdResult<fd_t> FdManager::Open(const vfs::Path &path, OpenMode flags)
{
    // Check if file exists in VFS
    auto exists_result = VfsModule::Get().FileExists(path);
    RET_UNEXPECTED_IF(!exists_result, FdError::kIoError);
    RET_UNEXPECTED_IF(!*exists_result, FdError::kNotFound));

    auto file_result = file_table_.GetOrCreate(path);
    RET_UNEXPECTED_IF_ERR(file_result);

    auto open_result = open_file_table_.OpenFile(file_result->Get(), flags);
    RET_UNEXPECTED_IF_ERR(open_result);

    FdTable *fd_table = GetCurrentProcessFdTable();
    RET_UNEXPECTED_IF(fd_table == nullptr, FdError::kIoError);

    auto fd_result = fd_table->Allocate(std::move(*open_result));
    RET_UNEXPECTED_IF_ERR(fd_result);

    return *fd_result;
}
\end{lstlisting}

\subsubsection*{Resource Lifecycle Management}

To ensure efficient memory usage and prevent resource leaks, the life cycle of \texttt{OpenFileEntry} and \texttt{File} objects is managed through intrusive reference counting. Both structures inherit from a \texttt{RefCounted} base class and are managed via smart pointers (\texttt{RefPtr} and \texttt{TaggedPointer}).

When a process closes a file descriptor (or terminates), the reference to the corresponding \texttt{OpenFileEntry} in the process's \texttt{FdTable} is released. If the reference count drops to zero --- indicating that no other file descriptors (across any process) refer to this open stream --- the \texttt{OpenFileEntry} is automatically deallocated and removed from the global \texttt{OpenFileTable}.

Consequently, the destruction of an \texttt{OpenFileEntry} releases its hold on the underlying \texttt{File} object. Similarly, if the reference count of the \texttt{File} object reaches zero, it implies that no active streams are reading from or writing to that specific file. The system then automatically reclaims the associated memory from the \texttt{FileTable}. This cascading deallocation mechanism ensures that kernel memory is only consumed for files that are actively in use by at least one process.

\section{Scheduling}

The scheduling module is the final core component of the operating system, relying heavily on and utilizing the previously described modules. Although the current implementation targets a single-core architecture for simplicity, the design is extensible to multi-core systems, as discussed later in this document.

\subsection{Process Structure}

The process structure is defined as follows:

\begin{lstlisting}[caption={Process Structure}, label={lst:processStruct}]
struct PACK Pid {
    u16 id;
    u64 count : 48;

    bool operator==(const Pid &other) const = default;
};

struct PACK ProcessFlags {
    bool KernelSpaceOnly : 1;
    bool PreserveFloats : 1;
};
static_assert(sizeof(ProcessFlags) == 1);

enum class ProcessState : u64 {
    kReady = 0,
    kWaitingForJoin,
    kTerminated,
    kLast,
};
static_assert(sizeof(ProcessState) == sizeof(u64));

struct Process : hal::Process {
    static constexpr size_t kMaxNameLength = vfs::kMaxComponentSize;

    /* Management */
    char name[kMaxNameLength];
    Pid pid;
    ProcessFlags flags;
    Thread *threads;
    u64 live_threads;
    u64 threads_to_clean;
    ProcessState state;
    WaitQueue<Thread, 3> *wait_queue;
    int status;

    /* Process resources */
    Mem::VPtr<Mem::AddressSpace> address_space;

    /* File descriptor table */
    Mem::VPtr<Fs::FdTable> fd_table;

    /* Standard I/O pipes (owned by process) */
    IO::Pipe<Fs::kStdioBufferSize> stdin_pipe;
    IO::Pipe<Fs::kStdioBufferSize> stdout_pipe;
    IO::Pipe<Fs::kStdioBufferSize> stderr_pipe;
};
\end{lstlisting}

\subsubsection{PID}
\label{subsubsec:pid}

As mentioned in the limitations section \ref{subsec:limitations}, the system imposes a hard limit on the maximum number of existing processes. This constraint allows for optimized process lookup via direct indexing. The \textbf{PID} (Process Identifier) is composed of a reservable identifier and an atomic counter, ensuring that each PID remains unique throughout the entire lifetime of the system.

\subsubsection{Process Flags}

\textbf{KernelSpaceOnly} -- enables the creation of kernel-only threads and processes. These processes do not require a separate user-space address space or user-space stack. This minimization of resource consumption improves performance; additionally, context switching between kernel-only threads does not necessitate switching the address space.

\textbf{PreserveFloats} -- indicates that all threads within the process save and restore floating-point registers during context switches by default. Disabling this flag allows the system to omit these potentially expensive operations for threads that do not utilize floating-point arithmetic.

\subsubsection{Process State}

The process state has less significance than the Thread State (described later) and is primarily utilized for resource management when waiting for a process to terminate. It ensures that process resources are not deallocated more than once.

\subsubsection{Address Space}

The address space is a fundamental component of the process structure. It defines all information regarding virtual memory, specifically establishing the translation between the virtual and physical layers. Each process operates within its own virtual address space, facilitating simpler memory management regarding fragmentation, performance, and security. Refer to Memory Management \ref{sec:memory} for further details.

\subsubsection{File Descriptor Table}

This table contains all file descriptors opened by threads executing within the process. Refer to the File System section \ref{section:fs} for more information.

\subsubsection{Pipes}

Pipes handle the buffered I/O of the process, primarily used for standard input and output communication with the user.

\subsubsection{Name}

The name of the process typically corresponds to the name of the executable. Unlike the unique PID, the process name is not required to be unique.

\subsubsection{Threads}

This field points to the first element of a doubly linked list of threads running in this environment. It is used primarily for operations such as termination (kill/exit).

\subsubsection{Live Threads and Threads to Clean}

These counters are used for synchronization with the \textbf{ProcessRipper}. Refer to Kernel Workers \ref{subsubsec:kworkers} for more details.
 
\subsubsection{Status}

The exit status of the process, which is passed to any thread waiting for the process to complete.

\subsubsection{Wait Queue}

The \textbf{Wait Queue} stores threads that are waiting for this process to finish. All threads in this queue are woken up upon process termination.

\subsection{Kernel Address Space}

The entire operating system shares a single Kernel Address Space. Every kernel process operates within this space. Additionally, the kernel address space is mapped into every user-space process's address space. This design choice enhances performance and simplifies architecture, as user threads frequently invoke system calls. Switching address spaces on every system call would incur significant performance overhead and complicate the logic required for handling syscalls.

\subsection{Thread Structure}

The thread structure is defined as follows:

\begin{lstlisting}[caption={Thread Structure}, label={lst:threadStruct}]
enum class UserPriority : u8 { kLow = 0, kMediumLow, kMedium, kMediumHigh, kHigh, kLast };

struct PACK Tid {
    u16 id;
    u64 count : 48;

    bool operator==(const Tid &other) const = default;
};

struct PACK ThreadFlags {
    SchedulingPolicy policy : 8;
    u8 priority : 8;
    UserPriority user_priority : 3;
    bool preserve_floats : 1;
    bool detached : 1;
    u64 padding : 43;
};
static_assert(sizeof(ThreadFlags) == 8);

enum class ThreadState : u64 {
    kReady = 0,
    kRunning,
    kSleeping,
    kBlockedOnWaitQueue,
    kWaitingForJoin,
    kTerminated,
    kLast,
};
static_assert(sizeof(ThreadState) == sizeof(u64));

static constexpr int kSchedulingIntrusiveLevel  = 0;
static constexpr int kSleepingIntrusiveLevel    = 1;
static constexpr int kProcessListIntrusiveLevel = 2;
static constexpr int kWaitQueueIntrusiveLevel   = 3;

struct Thread : data_structures::IntrusiveRbNode<Thread, u64, kSchedulingIntrusiveLevel>,
                data_structures::IntrusiveRbNode<Thread, u64, kSleepingIntrusiveLevel>,
                data_structures::IntrusiveListNode<Thread, kSchedulingIntrusiveLevel>,
                data_structures::IntrusiveListNode<Thread, kSleepingIntrusiveLevel>,
                data_structures::IntrusiveDoubleListNode<Thread, kSchedulingIntrusiveLevel>,
                data_structures::IntrusiveDoubleListNode<Thread, kWaitQueueIntrusiveLevel>,
                data_structures::IntrusiveDoubleListNode<Thread, kProcessListIntrusiveLevel> {
    /* Management */
    Tid tid;
    Pid owner;
    ThreadFlags flags;
    ThreadState state;
    void *retval;
    WaitQueue<Thread, kWaitQueueIntrusiveLevel> *wait_queue;

    /* Thread resources */
    void *kernel_stack;
    void *kernel_stack_bottom;
    void *user_stack;
    void *user_stack_bottom;

    /* Statistics */
    u64 kernel_time_ns;
    u64 user_time_ns;
    u64 timestamp;
    u64 timestamp_execution_start_ns;
    u64 num_interrupts;
    u64 num_syscalls;
    u64 num_context_switches;

    /* Arch */
    hal::Thread arch_data;

    NODISCARD u64 CalculateCpuTime();
};
\end{lstlisting}

\subsubsection{TID}

Similar to the PID \ref{subsubsec:pid}, the system limits the number of available threads. This property is utilized to create unique \textbf{TIDs} (Thread Identifiers), allowing for rapid lookups.

\subsubsection{Owner's PID}

The PID of the process that owns the thread.

\subsubsection{Thread Flags}

A collection of bitfields that determine how the scheduler manages the thread:

\textbf{SchedulingPolicy policy} -- defines the scheduling policy under which the thread currently operates. Refer to Policies \ref{subsec:policies} for more details.

\textbf{u8 priority} -- defines the internal priority of the thread within its assigned policy. This value is managed by the kernel.

\textbf{UserPriority user\_priority} -- may be specified by User Space to inform the scheduler of the relative importance of threads.

\textbf{bool preserve\_floats} -- specifies whether the floating-point state is preserved during context switches.

\textbf{bool detached} -- specifies whether the scheduler should automatically clean up the thread upon termination, without waiting for a join operation.

\subsubsection{Thread State}

Describes the current status of the thread. This state tracking allows the kernel to monitor each thread individually and verify system integrity, as only specific state transitions are permitted. The thread state transitions graph is defined as follows:

\newgeometry{top=1cm, bottom=1.5cm, left=1cm, right=1cm} 

\begin{figure}[p]
    \centering
    % Teraz mamy więcej miejsca, więc height może być większe
    \includesvg[height=0.95\textheight, width=\textwidth, keepaspectratio]{res/thread-states.svg}
    \caption{Thread State Transitions Graph}
    \label{fig:thread-states}
\end{figure}

\restoregeometry % Bardzo ważne: przywraca normalne marginesy dla reszty pracy

\subsubsection{Stacks}

Two distinct stacks are required for each thread: one for user space and one for kernel space. A separate kernel stack is essential for security and stability. Furthermore, sharing a single kernel stack is inefficient because context switches may occur within kernel code, such as during thread joining or other synchronization events.

\subsubsection{Statistics}

Statistics tracking allows for the analysis of execution specifics for each thread. This data is used to dynamically adjust the scheduling module and to debug or test the scheduler.

\subsubsection{Wait Queue}

Allows other threads to block and wait for a specific thread to finish execution (Thread joining).

\subsection{Kernel Workers}
\label{subsubsec:kworkers}

Before initializing the scheduling module, the operating system creates three essential kernel workers:

\textbf{Trace Dumper} -- responsible for dumping kernel traces to the terminal or storage files, ensuring debuggability and stability. This task cannot be performed directly by the kernel code during critical execution paths, as writing to devices or files is too slow for system calls or interrupt handlers. The buffers are dumped periodically every 20ms.

\textbf{Thread Ripper} -- responsible for the deallocation of thread resources, including descriptors and stacks.

\textbf{Process Ripper} -- responsible for the deallocation of process resources, including the address space.

\subsection{Intrusive Data Structures}

Since threads frequently migrate between different linked lists and data structures, allocating and freeing list nodes for every operation introduces significant overhead. To address this, the system employs intrusive data structures. Instead of allocating a node that contains a pointer to the object, the node structure is embedded directly within the object itself. Operations on the lists are performed by simply modifying the fields of the object.

\begin{lstlisting}[caption={Intrusive Nodes}, label={lst:intrusiveNodes}]
template <class T, int kIntrusiveLevel>
struct IntrusiveListNode {
    T *next;
};

template <class T, int kIntrusiveLevel>
struct IntrusiveDoubleListNode {
    T *next;
    T *prev;
};

template <class T, class KeyT, int kIntrusiveLevel>
struct IntrusiveRbNode {
    enum class Color : u8 {
        kBlack = 0,
        kRed   = 1,
    };

    T *parent;
    union {
        struct {
            T *left;
            T *right;
        };
        T *child[2];
    };

    Color color;
    KeyT key;
};
\end{lstlisting}

The Thread data structure \ref{lst:threadStruct} demonstrates the usage of such nodes. This approach offers multiple benefits, including:
\begin{itemize}
\item No dynamic allocation or deallocation during insert or pop operations.
\item Improved memory access patterns, the object is accessed directly rather than via a pointer from a separate node.
\item Verification of whether an object belongs to a list in \textbf{O(1)} time, given only the object itself.
\item Removal of the object from the list in \textbf{O(1)} time.
\item Removal of the object from the list without requiring access to the list head structure.
\end{itemize}

\subsection{Meta-Scheduler}

The scheduler architecture follows the \textbf{meta-scheduler} design pattern, which is common in modern operating systems. This approach relies on abstracting scheduling logic into Policies. Policies are primarily responsible for selecting the next task from the set of tasks they manage and reacting to thread behavior (e.g., punishing or rewarding threads with CPU time based on workload characteristics). The scheduler itself is responsible for all other operations, including:
\begin{itemize}
\item Managing thread states.
\item Transitioning threads to sleep.
\item Waking up threads.
\item Managing idle time.
\item Configuring next timing events via the timing infrastructure.
\item Blocking threads on wait queues.
\item Releasing threads from wait queues.
\end{itemize}
A hierarchy exists between policies, ensuring that threads from higher-priority policies are selected before threads from lower-priority ones.

\subsection{Timing Model}

The system implements a tickless kernel architecture. Instead of relying on a periodic interrupt (the \textbf{Kernel Tick}) at a fixed frequency, the scheduler calculates precisely when the next timing event must occur. This approach improves efficiency and precision.

\subsection{Policies}

The following scheduling policies have been implemented:

\textbf{Round Robin Scheduling Policy} -- simple policy that iterates through a linked list from front to back. Threads are ordered based on their arrival time in the policy.

\textbf{Priority Queue Scheduling Policy} -- policy that orders threads based on kernel-assigned priorities. Priorities are capped at a range of 0-64 to enable the use of an \textbf{O(1)} priority queue, known as a \textbf{Bitmap Priority Queue}. This structure maintains an array of linked lists representing individual priorities. Additionally, a bitmask indicates the presence of tasks at specific priority levels. Lookup operations utilize bitwise instructions (counting leading/trailing zeros) to efficiently find the minimum or maximum priority value (\textbf{O(1)}).

\textbf{Multi-Level Feedback Queue (MLFQ) Scheduling Policy} -- policy that segregates threads into distinct queues according to their workload characteristics. The policy penalizes CPU-bound threads by demoting them to lower priorities, whereas I/O-bound threads are elevated to higher priorities, thereby favoring interactive performance. To prevent the starvation of low-priority tasks, a periodic reset mechanism promotes all threads to the highest priority queue every 100ms. Within each queue, threads are managed using \textbf{Red-Black trees}, sorted by a key that combines user-defined priority and aggregated CPU burst times (the amount of time a thread spends executing on the CPU before it either completes, requires I/O operations, or is interrupted by the operating system). This ensures that each thread in the given queue receives a fair share of CPU time.

\noindent These policies establish a hierarchy defined by the following enumeration:

\begin{lstlisting}[caption={Scheduling Policy Hierarchy}, label={lst:policyHierarchy}]
// PO > P1 > .. > P4
enum SchedulingPolicy {
    kUberTask_PQ_P0 = 0,
    kDrivers_PQ_P1,
    kUrgentTasks_PQ_P2,
    kNormalTasks_MLFQ_P3,
    kBackgroundTasks_RR_P4,
    kLast,
};
\end{lstlisting}

Each policy is designated for a specific group of tasks:

\textbf{Uber Tasks} -- Tasks that must be executed as quickly as possible, such as emergency recovery actions or critical kernel state preservation (e.g., saving state before shutdown or terminating processes during out-of-memory conditions).

\textbf{Drivers} -- Driver tasks that require immediate execution to prevent device blocking and ensure smooth system operation (e.g., audio drivers or network interfaces).

\textbf{Urgent Tasks} -- Tasks that are less critical than drivers but more important than standard user tasks. These may include privileged user-space tasks that consume data from drivers.

\textbf{Normal Tasks} -- The most common group of tasks, comprising standard user-space programs such as graphical interfaces and data processing applications. Basic kernel workers, including those listed in the kernel workers section \ref{subsubsec:kworkers}, also belong to this category.

\textbf{Background Tasks} -- Tasks that are not time-critical and should only be executed when the system is otherwise idle. Examples include update checks or non-urgent cleanup operations.

\subsubsection{Policies Abstraction}
\label{subsec:policies}

The policy abstraction is defined as follows:

\begin{lstlisting}[caption={Policy Abstraction}, label={lst:policyStruct}]
struct Policy {
    struct {
        Thread *(*pick_next_task)(void *);

        void (*add_task)(void *, Thread *);
        void (*remove_task)(void *, Thread *);

        u64 (*get_preempt_time)(void *, Thread *);
        bool (*is_first_higher_priority)(void *, Thread *, Thread *);
        bool (*validate_flags)(void *, const ThreadFlags *);

        void (*on_thread_yield)(void *, Thread *);
        void (*on_periodic_update)(void *, u64 current_time_ns);
    } cbs;
    void *self;
};
\end{lstlisting}

As shown, the primary operation is \textbf{pick\_next\_task}, alongside standard \textbf{add\_task} and \textbf{remove\_task} operations. Additionally, helper functions are provided for the scheduler and for statistics gathering.

\subsection{Sleeping}

To provide high-precision sleeping, the system relies on one-shot, precise timing events. Upon receiving a timer interrupt, the scheduler determines the timestamp for the next event based on the system state, which includes the current thread preemption time and the wake-up times of sleeping threads. Consequently, the scheduler must inspect the sleeping queue to process expired events. To ensure high performance and stable time complexity, an Intrusive Red-Black Tree was selected as the underlying data structure for the \textbf{Sleeping Queue}. The critical operations are \textbf{Insert}, \textbf{ExtractMin}, and \textbf{Remove}, all of which must have predictable execution times. The requirement for efficient arbitrary removal excluded binary heaps, while the need for stability excluded heaps with amortized complexity bounds. The Red-Black Tree satisfied all requirements and was already implemented for other system components, making it the optimal choice.

% ==================================================================

\chapter{Results}
TODO

\section{User's Manual}
TODO

\subsection{Building and Running the OS}
TODO

\subsection{Writing Own Programs}
TODO

\subsection{Libc alkos.h}
TODO

\subsection{Syscalls}
TODO

\section{Example Programs}
TODO

\section{Performance Analysis}
TODO

\subsection{KMalloc Performance}
TODO

\subsection{KFree Performance}
TODO

\subsection{Context Switch Performance}
TODO

\subsection{Syscall Performance}
TODO

\subsection{Scheduler Tests}
TODO

% ------------------------------- BIBLIOGRAPHY ---------------------------

\printbibliography[heading=bibintoc]

\pagenumbering{gobble}
\thispagestyle{empty}



% ----------------------- LIST OF SYMBOLS AND ABBREVIATIONS ------------------
\chapter*{List of symbols and abbreviations}

\begin{tabular}{cl}
API & Application Programming Interface \\
APIC & Advanced Programmable Interrupt Controller \\
CRTP & Curiously Recurring Template Pattern \\
IDT & Interrupt Descriptor Table \\
ISR & Interrupt Service Routine \\
LAPIC & Local Advanced Programmable Interrupt Controller \\
LIT & Logical Interrupt Table \\
MLFQ & Multi-Level Feedback Queue \\
MMIO & Memory-Mapped I/O \\
MMU & Memory Management Unit \\
PIC & Programmable Interrupt Controller \\
PID & Process IDentifier \\
PIT & Programmable Interrupt Timer \\
TID & Thread IDentifier \\
TSC & TimeStamp Counter \\
TSS & Task State Segment \\
VFS & Virtual File System \\
\end{tabular}
\\
\thispagestyle{empty}


% ----------------------------  LIST OF FIGURES --------------------------------
\listoffigures
\thispagestyle{empty}

% -----------------------------  LIST OF TABLES --------------------------------
\renewcommand{\listtablename}{List of Tables}
\listoftables
\thispagestyle{empty}

\end{document}

% ==================================================================
% TODOS:
% - wytlumaczyc na starcie co zakladamy etc i dlaczego np segmenty
